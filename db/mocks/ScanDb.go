// Code generated by mockery v2.18.0. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"

	model "guard_rails/model"
)

// ScanDb is an autogenerated mock type for the ScanDb type
type ScanDb struct {
	mock.Mock
}

// CreateNewScan provides a mock function with given fields: ctx, repositoryId
func (_m *ScanDb) CreateNewScan(ctx context.Context, repositoryId int64) (*model.Scan, error) {
	ret := _m.Called(ctx, repositoryId)

	var r0 *model.Scan
	if rf, ok := ret.Get(0).(func(context.Context, int64) *model.Scan); ok {
		r0 = rf(ctx, repositoryId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Scan)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, repositoryId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetScanWithStatus provides a mock function with given fields: ctx, repositoryId, status
func (_m *ScanDb) GetScanWithStatus(ctx context.Context, repositoryId int64, status []model.ScanStatus) (*model.Scan, error) {
	ret := _m.Called(ctx, repositoryId, status)

	var r0 *model.Scan
	if rf, ok := ret.Get(0).(func(context.Context, int64, []model.ScanStatus) *model.Scan); ok {
		r0 = rf(ctx, repositoryId, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Scan)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64, []model.ScanStatus) error); ok {
		r1 = rf(ctx, repositoryId, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetScans provides a mock function with given fields: ctx, repositoryName
func (_m *ScanDb) GetScans(ctx context.Context, repositoryName string) ([]model.Scan, error) {
	ret := _m.Called(ctx, repositoryName)

	var r0 []model.Scan
	if rf, ok := ret.Get(0).(func(context.Context, string) []model.Scan); ok {
		r0 = rf(ctx, repositoryName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Scan)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, repositoryName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartScan provides a mock function with given fields: ctx, scanId
func (_m *ScanDb) StartScan(ctx context.Context, scanId int64) error {
	ret := _m.Called(ctx, scanId)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, scanId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StopScan provides a mock function with given fields: ctx, scanId, findings, status
func (_m *ScanDb) StopScan(ctx context.Context, scanId int64, findings model.Findings, status model.ScanStatus) error {
	ret := _m.Called(ctx, scanId, findings, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, model.Findings, model.ScanStatus) error); ok {
		r0 = rf(ctx, scanId, findings, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateScanStatus provides a mock function with given fields: ctx, scanId, status
func (_m *ScanDb) UpdateScanStatus(ctx context.Context, scanId int64, status model.ScanStatus) error {
	ret := _m.Called(ctx, scanId, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, model.ScanStatus) error); ok {
		r0 = rf(ctx, scanId, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewScanDb interface {
	mock.TestingT
	Cleanup(func())
}

// NewScanDb creates a new instance of ScanDb. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewScanDb(t mockConstructorTestingTNewScanDb) *ScanDb {
	mock := &ScanDb{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
